# AiSD lista 2 - Wojciech Adamiec
## Zadania Deklarowane: 2,

### Zadanie 2.
:::info
![alt text](https://i.imgur.com/mIJrT9p.png)
:::

```=
def policz(I[1...n]):
    S = {}
    koniec = -INF
    I.sortuj(dla par <p, k> -> k.rosnąco)
    Dla każdego <p, k> w I:
        Jeśli (p >= koniec):
            S.dodaj(<p, k>)
            koniec = k
    Zwróć S
```

Nasz algorytm zwraca zbiór $S$. Załóżmy, że $S'$ jest zbiorem optymalnym zbierającym najkrótsze odcinki. Rozpatrujemy pierwszą różnice patrząc od lewej strony.

Nasz algorytm wybrał odcinek $s$. Optymalny algorytm wybrał $s'$. Istnieją trzy przypadki:

1. $s.koniec > s'.koniec$ (Niemożliwe, idziemy po posortowanej tablicy)

2. $s.koniec < s'.koniec$

![](https://i.imgur.com/69We0C6.png)
Przypadek nie może zajść, bo wówczas $S'$ nie spełniałby założeń: Mógłby wziąć odcinek $A$ zamiast $B$, a potem kontynuować bez zmian.

4. $s.koniec = s'.koniec$ (dostaniemy rozwiązanie inne, ale również optymalne)

**Złożoność czasowa**:
$O(n \log n)$

**Złożoność pamięciowa**:
$O(n)$