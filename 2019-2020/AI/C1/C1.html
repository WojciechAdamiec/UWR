<html><head><style>body {
   color: black;
}
</style></head><body><h1 id="ai-wiczenia-z1-c1-">AI Ćwiczenia (Z1, C1)</h1>
<p>Wojciech Adamiec, 310064</p>
<h2 id="z1-1">Z1.1</h2>
<h3 id="1-">1.)</h3>
<p>Dla rozmiaru n = 2:</p>
<p><img src="https://i.imgur.com/Yy7vTof.png" alt="alt text"></p>
<p>Są to wszystkie rozwiązania.</p>
<p>(W sumie mamy 2^4 możliwości, łatwo zauważyć, że tylko 2/16 możliwości spełniają zadanie)</p>
<h3 id="2-">2.)</h3>
<p>Dla rozmiaru n = 3:</p>
<p><img src="https://i.imgur.com/4V3xo1o.png" alt="alt text"></p>
<p>A zatem rozwiązań jest więcej niż n.</p>
<h2 id="z1-2">Z1.2</h2>
<p>Stanem jest informacja o aktualnym położeniu (jakie miasto) oraz ilości paliwa w baku.</p>
<p>Stanem końcowym jest każdy stan, w którym położeniem jest miasto, do którego chcemy dotrzeć.</p>
<p>Akcjami są takie przejazdy, że:</p>
<ol>
<li>Nowe miasto jest połączone w grafie z aktualnym miastem.</li>
<li>Koszt przejazdu jest mniejszy-równy od aktualnej ilości paliwa w baku.</li>
</ol>
<p>Wtedy stan zmienia się tak, że:</p>
<p>Aktualne położenie &lt;--- nowe miasto</p>
<p>Ilość paliwa &lt;--- (Ilość paliwa - koszt przejazdu), gdy w nowym mieście nie ma stacji paliw</p>
<p>lub </p>
<p>Ilość paliwa &lt;--- max. ilość paliwa w baku, gdy w nowym mieście jest stacja paliw</p>
<h2 id="z1-3">Z1.3</h2>
<p>Zadanie jest trochę niedoprecyzowane i niestety nie wiem na co mogę sobie pozwolić. Zdecydowałem, że najlepszym rozwiązaniem będzie przed włączeniem algorytmu A* zrobienie pewnego preprocessingu. Planuje włączyć algorytm Djikstry zaczynając go od naszego celu podróży, tak, że każdemu wierzchołkowi przypisze odległość wyliczaną tym algorytmem od naszego celu. Podczas działania tego algorytmu nie będę zwracał uwagi na paliwo, optymistycznie założę, że da się podróżować miedzy każdymi miastami, miedzy którymi w oryginalnym grafie jest krawędź. W ten sposób podczas działania naszego głównego algorytmu A* heurystyką będzie po prostu wartość zapisana przy wierzchołku podczas preprocessingu. Mamy pewność, że jest to heurystyka optymistyczna (jak się da dojechać uwzględniając paliwo, to bez niego będzie co najmniej tak samo szybko). Problem jaki widzę jest taki, że być może nasz graf jest bardzo duży lub wręcz nieskończony. W takim przypadku nie chcemy Djikstry wykonywać dla całego grafu, a tylko dla jego części. Trzeba by jakoś sensownie zdecydować dla jak wielu (i których wierzchołków) chcemy wykonać Djikstrę.</p>
<h2 id="z1-4">Z1.4</h2>
<p>Będziemy chcieli zrobić to samo co w zadaniu 3. Dodatkowo musimy policzyć średnią wartość krawędzi w grafie (lub medianie?). Następnie liczymy współczynnik:</p>
<p>D = Max pojemność baku / średnia wartość krawędzi.</p>
<p>Ten współczynnik przechowuje informacje ile średnio krawędzi możemy przejechać na pełnym baku. Następnie wracamy do rozwiązania z zad. 3 oprócz tego, że znajdujemy odległość od celu dla każdego wierzchołka algorytmem Djikstry to chcemy dodatkowo uwzględniać, że w danym wierzchołku znajduje się stacja paliw. W tym celu odejmujemy dla takiego wierzchołka od minimalnej długości do celu jeszcze wartość:</p>
<p>np. C * 1/D, gdzie C to jakaś stała</p>
<p>W ten sposób A* będzie preferował drogi przez miasta ze stacjami paliw, a to &quot;preferowanie&quot; jest uzależnione od tego, jak często musimy średnio odwiedzać takie stacje. (Jeśli średnio co 2 miasta musimy tankować to wtedy 1/D jest duże (1/2), ale jeśli tankować musimy średnio co 30 miast to wówczas 1/D jest male (1/30). Heurystyka jest dalej optymistyczna (skoro w zad. 3 była, a teraz tylko odejmujemy jakieś wartości od wierzchołków to nadal jest optymistyczne). Dbamy, żeby nie wejść na ujemne liczby (najniżej jak może być to 0). Heurystyka ta być może nie jest spójna, nie jestem w stanie rozstrzygnąć tego czy jest &#39;sensowna&#39;. Jestem w stanie podać przykład grafu, gdzie zadziała ona lepiej niż ta z Zad. 3, ale również mogę podać kontrprzykład. Pytanie jak sprawa będzie wyglądać dla &quot;uśrednionego&quot; grafu.</p>
<h2 id="z1-5">Z1.5</h2>
<h3 id="1-">1.)</h3>
<p>Każdy skoczek może albo zostać w miejscu albo przejść na jedno z 8 pól. Uogólniając dla podzbioru k skoczków mamy rozgałęzienie nie większe niż (9 ^ k - 1). Jedynka bierze się stąd, że nie możemy wszystkim skoczkom pozostać w miejscu.</p>
<h3 id="2-">2.)</h3>
<p>Heurystyka optymistyczna to taka, że dla każdego wierzchołka zwraca wartość, która jest co najwyżej tak duża jak prawdziwa odległość do celu.</p>
<p>Zrozumiałem to zadanie tak, że przenosimy ciąg skoczków w jakieś tam miejsca. Mamy jedną heurystykę <em>h</em>.</p>
<h3 id="2a-">2A.)</h3>
<p>Min. jest na pewno bardziej optymistyczne od maksimum, wiec pokaże dla maximum.</p>
<h3 id="2b-">2B.)</h3>
<p>Maximum zwróci nam minimalna ilość ruchów potrzebnych do przestawienia nam &#39;najgorszego&#39; skoczka (lub mniejsza od faktycznej ilości ruchów). Jeśli chcemy przestawić ciąg skoczków to w szczególności musimy przestawić również tego &#39;najgorszego&#39;, dla którego heurystyka jest optymistyczna. (faktyczna liczba ruchów jest nie mniejsza niż optymistyczna heurystyka dla &#39;najgorszego&#39;) Zatem ta heurystyka również jest optymistyczna.</p>
<h3 id="2c-">2C.)</h3>
<p>To nie jest heurystyka optymistyczna, kontrprzykład:</p>
<p>Niech <em>h</em> będzie zwracać 3/4 ilości faktycznych ruchów potrzebnych do przestawienia skoczka (zaokrąglając w górę). Wtedy h jest optymistyczna. Dla 2 skoczków, z których każdy potrzebuje 1 ruchu, aby dotrzeć do celu suma heurystyk zwróci nam 2, kiedy można dotrzeć do celu w jednym ruchu. (Wybierając podzbiór 2 skoczków i przesuwając ich do celu)</p>
<h3 id="3-">3.)</h3>
<p>Dla podzbioru k skoczków wybieramy jednego z nich na k sposobów i można go ruszyć na 8 sposobów. Mamy zatem max. rozgałęzienie (8k).</p>
<p>Zauważmy, że z tych heurystyk największą jest zawsze C, pokaże zatem tylko, że C istotnie jest heurystyką optymistyczną (pozostałe wtedy też muszą być).</p>
<p>Skoro w każdym ruchu przenosimy tylko jednego skoczka, to wtedy w sumie musimy wykonać co najmniej tyle ruchów ile musielibyśmy zrobić przesuwając po kolei skoczków niezależnie od siebie (ignorujemy pozycje pozostałych). Nasza heurystyka jest bardziej optymistyczna, bo dla każdego skoczka osobno bierzemy ilość ruchów mniejszą równą faktycznej ilości ruchów potrzebnych do dotarcia do celu. (Dodatkowo nie przejmujemy się jeszcze tym, że skoczki mogą się wzajemnie blokować). Zatem jest to heurystyka optymistyczna.</p>
<h2 id="z1-6">Z1.6</h2>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choice

N = <span class="hljs-number">8</span>
queens = []

Board = np.zeros((N, N), dtype=int)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(x, y)</span>:</span>
    Board[x][y] = <span class="hljs-number">1</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span><span class="hljs-params">(x, y)</span>:</span>
    Board[x][y] = <span class="hljs-number">0</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ok</span><span class="hljs-params">(x, y)</span>:</span>
    <span class="hljs-keyword">for</span> queen <span class="hljs-keyword">in</span> queens:
        <span class="hljs-keyword">if</span> x == queen[<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> y == queen[<span class="hljs-number">1</span>]:
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
    <span class="hljs-keyword">if</span> abs(queen[<span class="hljs-number">0</span>] - x) == abs(queen[<span class="hljs-number">1</span>] - y):
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span><span class="hljs-params">()</span>:</span>
    i = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> i &lt; N:
        news = []
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(N):
            <span class="hljs-keyword">if</span> ok(i, j):
            news.append((i, j))
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> news:
            i = <span class="hljs-number">0</span>
            queens.clear()
        <span class="hljs-keyword">else</span>:
            chosen = choice(news)
            queens.append(chosen)
            i = i + <span class="hljs-number">1</span>
    <span class="hljs-keyword">for</span> queen <span class="hljs-keyword">in</span> queens:
        add(queen[<span class="hljs-number">0</span>], queen[<span class="hljs-number">1</span>])


work()
print(Board)
</code></pre>
<h3 id="1-">1.)</h3>
<p>Lekka modyfikacja i program pozwala policzyć pierwszy podpunkt (dla wywołania work dużo razy).
Wynik to: 0.069456</p>
<h3 id="2-">2.)</h3>
<p>Wyrzucam wyświetlanie planszy i robię kilka optymalizacji, wtedy dla (N = 70) jestem w stanie jeszcze wykonać zadanie w 5 sekund, przy czym problemem jest tutaj niestabilność algorytmu, czasem potrzeba 2 sekund czasem 7, zatem ustalenie dokładnej liczby jest niemożliwe, przy odrobinie szczęścia (być może sporej odrobinie) możemy każde ułożenie zrobić za pierwszym razem.</p>
<h2 id="c1-2-i-c1-3">C1.2 i C1.3</h2>
<p>Wszystkich możliwych rąk Figuranta jest 4368, a wszystkich możliwych rąk Blotkarza jest 376992. Daje to w sumie 1,646,701,056 różnych konfiguracji. Powinniśmy przejrzeć wszystkie, zobaczyć w ilu wygrywa Blotkarz, a następnie podzielić liczbę zwycięstw przez liczbę wszystkich konfiguracji. Okazuje się jednak, że nie musimy przeglądać wszystkich możliwych konfiguracji (których jest dużo i być może długo czekalibyśmy na wynik). Wystarczy dla każdej ręki Figuranta (Blotkarza) znaleźć &quot;najmocniejszy&quot; pokerowy układ. Będziemy chcieli dowiedzieć się ile różnych rąk przypada na dany układ. Dzięki temu rozważamy przypadków zaledwie (4368 + 376992). Poniższy obrazek pozwala zobrazować co mamy do tej pory.</p>
<p><img src="https://i.imgur.com/3BKF0nl.png" alt="alt text"></p>
<p>Bardzo łatwo zauważyć, że z danych, które zebraliśmy można szybko policzyć ilość konfiguracji, w których zwycięża Blotkarz.</p>
<h2 id="c1-4">C1.4</h2>
<p>Każdy wróg będzie poruszał się po ustalonych polach. Jego ścieżką będzie tablica kolejnych pól. Oznacza to, że w naszym stanie dla danego wroga musimy jedynie pamiętać indeks aktualnej pozycji.</p>
<p>Stanem będzie aktualne położenie gracza oraz indeksy wszystkich wrogów.</p>
<p>Akcją będzie ruch WSAD (ograniczony przez ściany). W każdej akcji indeksy wszystkich wrogów zwiększają się o 1 (modulo długość trasy).</p>
<p>Skoro chcemy używać przeszukiwania wszerz do znajdowania rozwiązania to musimy upewnić się że, stanów nie jest zbyt dużo. W tym celu możemy zrobić 2 rzeczy:</p>
<h3 id="1-">1.)</h3>
<p>Upewnić się, że mamy bardzo dużo ścian, a co za tym idzie jak najmniej pól, w których może znajdować się gracz. W szczególności wszystkie tunele powinny mieć szerokość 1.</p>
<h3 id="2-">2.)</h3>
<p>Upewnić się, NWD długości ścieżek wrogów jest stosunkowo niewielkie. Zauważmy, że dla każdego położenia gracza w labiryncie mamy tak naprawdę więcej niż jeden stan. Jest to związane z mnogością konfiguracji położeń wrogów na ich zdefiniowanych ścieżkach. Jeżeli jednak NWD długości ścieżek wrogów będzie stosunkowo niewielkie np. 16, to wówczas ilość stanów będzie stosunkowo niewielka (np. 16 * ilość pól).</p>
<h3 id="przyk-adowy-labirynt">Przykładowy labirynt</h3>
<p><img src="https://i.imgur.com/5WhM0iG.png" alt="alt text"></p>
<h2 id="c1-5">C1.5</h2>
<p>Przestrzeń stanów rzeczywiście jest duża, jej rozmiar możemy szacować jako iloczyn dostępnych pól dla każdego z przyjaciół. Np. jeśli rozważamy <em>K</em> przyjaciół i każdy z nich może być w jednym z <em>N</em> wierzchołków to wówczas rozmiar naszej przestrzeni jest równy (<em>N^K</em>). (Dla wersji bez możliwości pasowania, być może stanów jest mniej)</p>
<p>Rozpatrzę problem z podpunktu <em>b)</em> gdzie przyjaciel może spasować ruch. W tym celu tworzymy algorytm podzielony na 2 fazy:</p>
<h3 id="faza-1">Faza 1</h3>
<p>Wykonujemy przeszukiwanie BFS jednocześnie dla każdego z przyjaciół, tzn. wykonujemy po jednym obrocie pętli standardowego BFS&#39;a dla każdego z przyjaciół. Dla każdego wierzchołka będziemy trzymali listę przyjaciół, która do tej pory odwiedziła go podczas działania fazy 1. Jeśli w pewnym momencie, jakiś wierzchołek będzie miał już na swojej liście wszystkich przyjaciół wówczas znaleźliśmy miejsce naszego spotkania i przechodzimy do fazy 2. Jeżeli faza 1 zakończy się, a żaden wierzchołek nie będzie miał wszystkich przyjaciół na swojej liście wówczas stwierdzamy, że spotkanie jest niemożliwe.</p>
<h3 id="faza-2">Faza 2</h3>
<p>Znaleźliśmy już miejsce spotkania, teraz wystarczy wykonać zwykłe przeszukiwanie BFS dla każdego przyjaciela i znaleźć najkrótszą drogę do miejsca spotkania (lub być może da się ją odtworzyć z Fazy 1 - to zależy od implementacji). Przyjaciele, którzy przyjdą na miejsce spotkania za wcześnie będą po prostu pasować tak długo, aż przyjaciel, który zaczynał najdalej od miejsca spotkania w końcu zjawi się na miejsce.</p>
</body></html>